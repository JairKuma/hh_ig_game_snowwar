property pObjectCacheon construct mereturn TRUEendon deconstruct mepObjectCache = void()return TRUEendon Refresh me, tTopic, tdatacase tTopic of#gameend:if GetObject(#session).exists("user_game_index") thenme.getGameSystem().executeGameObjectEvent(GetObject(#session).GET("user_game_index"), #gameend)end if#update_game_object:return me.updateGameObject(tdata)#verify_game_object_id_list:return me.verifyGameObjectList(tdata)#snowwar_event_0,#create_game_object:return me.createGameObject(tdata)#snowwar_event_1,#remove_game_object:return me.removeGameObject(tdata[#id])#snowwar_event_8:playSound("LS-throw")return me.createSnowballGameObject(tdata)#world_ready:return me.createStoredObjects()otherwise:return error(me, "Undefined event!" && tTopic && "for" && me.pID, #Refresh)end caseendon createStoredObjects meif pObjectCache = void() then return TRUErepeat with tDataObject in pObjectCacheme.createGameObject(tDataObject)end repeatpObjectCache = void()endon createGameObject me, tDataObjecttGameSystem = me.getGameSystem()if tGameSystem.getWorldReady() = FALSE thenif pObjectCache = void() thenpObjectCache = []end ifpObjectCache.add(tDataObject)return TRUEend iftGameSystem.createGameObject(tDataObject[#id], tDataObject[#str_type], tDataObject[#objectDataStruct])tGameObject = tGameSystem.getGameObject(tDataObject[#id])if tGameObject = FALSE thenreturn error(me, "Unable to create game object:" && tDataObject[#id], #createGameObject)end iftGameObject.setGameObjectProperty(tDataObject)tGameObject.define(tDataObject)return TRUEendon updateGameObject me, tDataObjecttGameSystem = me.getGameSystem()tGameObject = tGameSystem.getGameObject(tDataObject[#id])if tGameObject = FALSE thenreturn error(me, "Game object not found:" && tDataObject[#id], #updateGameObject)end iftOldValues = tGameObject.pGameObjectSyncValuestNewValues = tDataObject[#objectDataStruct]repeat with i = 1 to tNewValues.count thentKey = tNewValues.getPropAt(i)if tOldValues[tKey] <> tNewValues[tKey] thenput("** Obj" && tDataObject[#id] && "NOT IN SYNC:" && tKey && tOldValues[tKey] & ", server says:" && tNewValues[tKey])end ifend repeattGameSystem.updateGameObject(tDataObject[#id], tDataObject[#objectDataStruct])return tGameObject.define(tDataObject)endon removeGameObject me, tObjectIDtGameSystem = me.getGameSystem()return tGameSystem.removeGameObject(tObjectID)endon verifyGameObjectList me, tObjectIdListtGameSystem = me.getGameSystem()tAllGameObjectIds = tGameSystem.getGameObjectIdsOfType(#all)repeat with tObjectID in tAllGameObjectIdsif tObjectIdList.getPos(tObjectID) < 1 thentGameSystem.removeGameObject(tObjectID)end ifend repeatreturn TRUEendon createSnowballGameObject me, tdatatGameSystem = me.getGameSystem()tThrowerObject = tGameSystem.getGameObject(string(tdata.int_thrower_id))tThrowerLoc = tThrowerObject.getLocation()tGameObjectStruct = [:]tGameObjectStruct.addProp(#type, 1)tGameObjectStruct.addProp(#int_id, tdata.int_id)tGameObjectStruct.addProp(#id, tdata.id)tGameObjectStruct.addProp(#x, tThrowerLoc.x)tGameObjectStruct.addProp(#y, tThrowerLoc.y)tGameObjectStruct.addProp(#z, tThrowerLoc.z)tGameObjectStruct.addProp(#movement_direction, 0)tGameObjectStruct.addProp(#trajectory, tdata.trajectory)tGameObjectStruct.addProp(#time_to_live, 0)tGameObjectStruct.addProp(#int_thrower_id, tdata.int_thrower_id)tGameObjectStruct.addProp(#parabola_offset, 0)tObject = tGameSystem.createGameObject(tdata[#id], "snowball", tGameObjectStruct)if tObject = FALSE thenreturn error(me, "Cannot create snowball object!", #createSnowballGameObject)end iftObject.define(tGameObjectStruct)tObject.calculateFlightPath(tGameObjectStruct, tdata.TargetX, tdata.TargetY)return TRUEend
property SUBTURN_MOVEMENT, PLAYER_HEIGHT, pIsOwnPlayer, pRoomObject, pActiveEffects, pDump, pWalkLoopon construct meSUBTURN_MOVEMENT = getIntVariable("snowwar.object_avatar.subturn_movement")pActiveEffects = []return TRUEendon deconstruct merepeat with tEffect in pActiveEffectstEffect.deconstruct()end repeatpActiveEffects = []tWorld = me.getGameSystem().getWorld()if tWorld <> FALSE thentWorld.clearObjectFromTileSpace(me.getObjectId())end ifme.stopWalkLoop()me.removeRoomObject()return TRUEendon define me, tGameObjecttGameObject = tGameObject.duplicate()me.setGameObjectProperty(tGameObject)me.setGameObjectProperty(#objectDataStruct, void())tGameSystem = me.getGameSystem()if tGameSystem = FALSE then return FALSEme.createRoomObject(tGameObject)if tGameObject[#objectDataStruct].findPos(#next_tile_x) > 0 and tGameObject[#objectDataStruct].findPos(#next_tile_y) > 0 thenme.pGameObjectNextTarget.setTileLoc(tGameObject[#objectDataStruct][#next_tile_x], tGameObject[#objectDataStruct][#next_tile_y])end ifif tGameObject[#objectDataStruct].findPos(#move_target_x) > 0 and tGameObject[#objectDataStruct].findPos(#move_target_y) > 0 thenme.pGameObjectFinalTarget.setLoc(tGameObject[#objectDataStruct][#move_target_x], tGameObject[#objectDataStruct][#move_target_y])end ifme.reserveSpaceForObject()PLAYER_HEIGHT = me.getGameObjectProperty(#gameobject_height)if tGameObject[#name] = GetObject(#session).GET(#userName) thenpIsOwnPlayer = TRUEme.getGameSystem().sendGameSystemEvent(#statusbar_health_update, me.getProp(#pGameObjectSyncValues, #hit_points))me.getGameSystem().sendGameSystemEvent(#statusbar_ballcount_update, me.getProp(#pGameObjectSyncValues, #snowball_count))end ifreturn TRUEendon update meif pActiveEffects.count = 0 then return TRUErepeat with i = 1 to pActiveEffects.counttEffect = pActiveEffects[i]if tEffect.pActive thentEffect.update()elsetEffect.deconstruct()pActiveEffects.deleteAt(i)end ifend repeatreturn TRUEendon executeGameObjectEvent me, tEvent, tdataif pDump then put "* executeGameObjectEvent on" && me.getObjectId() & ":" && tEvent && tdatatstate = me.getProp(#pGameObjectSyncValues, #activity_state)tPossibleStates = [getIntVariable("ACTIVITY_STATE_NORMAL"), getIntVariable("ACTIVITY_STATE_INVINCIBLE_AFTER_STUN")]case tEvent of#send_set_target_tile:if not me.getStateAllowsMoving() then return TRUEtWorldLoc = me.getGameSystem().convertTileToWorldCoordinate(tdata[#tile_x], tdata[#tile_y])me.getGameSystem().sendGameEventMessage([#integer: 0, #integer: tWorldLoc[1], #integer: tWorldLoc[2]])#send_throw_at_player:if pIsOwnPlayer thenif me.getProp(#pGameObjectSyncValues, #snowball_count) <= 0 thenme.getGameSystem().sendGameSystemEvent(#statusbar_ballcount_update, me.getProp(#pGameObjectSyncValues, #snowball_count))end ifend ifme.getGameSystem().sendGameEventMessage([#integer: 1, #integer: integer(tdata[#target_id]), #integer: tdata[#trajectory]])#send_throw_at_loc:if pIsOwnPlayer thenif me.getProp(#pGameObjectSyncValues, #snowball_count) <= 0 thenme.getGameSystem().sendGameSystemEvent(#statusbar_ballcount_update, me.getProp(#pGameObjectSyncValues, #snowball_count))end ifend ifme.getGameSystem().sendGameEventMessage([#integer: 2, #integer: tdata[#targetloc].x, #integer: tdata[#targetloc].y, #integer: tdata.trajectory])#send_create_snowball:if me.getProp(#pGameObjectSyncValues, #snowball_count) >= getIntVariable("snowwar.snowball.maximum") thenreturn TRUEend ifif not me.getStateAllowsMoving() thenreturn TRUEend ifme.getGameSystem().sendGameEventMessage([#integer: 3])#substract_ball_count:if me.getProp(#pGameObjectSyncValues, #snowball_count) <= 0 thenreturn TRUEend ifme.setProp(#pGameObjectSyncValues, #snowball_count, me.getProp(#pGameObjectSyncValues, #snowball_count) - 1)if pIsOwnPlayer thenme.getGameSystem().sendGameSystemEvent(#statusbar_ballcount_update, me.getProp(#pGameObjectSyncValues, #snowball_count))end if#increase_ball_count:me.setProp(#pGameObjectSyncValues, #snowball_count, (me.getProp(#pGameObjectSyncValues, #snowball_count) + 1))if pIsOwnPlayer thenme.getGameSystem().sendGameSystemEvent(#statusbar_ballcount_update, me.getProp(#pGameObjectSyncValues, #snowball_count))playSound("LS-getsnowball")end if#set_ball_count:me.setProp(#pGameObjectSyncValues, #snowball_count, tdata[#value])if pIsOwnPlayer thenme.getGameSystem().sendGameSystemEvent(#statusbar_ballcount_update, me.getProp(#pGameObjectSyncValues, #snowball_count))end if#substract_hit_points:if me.getProp(#pGameObjectSyncValues, #hit_points) <= 0 thenreturn TRUEend ifme.setProp(#pGameObjectSyncValues, #hit_points, me.getProp(#pGameObjectSyncValues, #hit_points) - 1)if pIsOwnPlayer thenme.getGameSystem().sendGameSystemEvent(#statusbar_health_update, me.getProp(#pGameObjectSyncValues, #hit_points))end if#player_resurrected:me.setProp(#pGameObjectSyncValues, #hit_points, getIntVariable("snowwar.health.maximum"))if pIsOwnPlayer thenme.getGameSystem().sendGameSystemEvent(#statusbar_health_update, me.getProp(#pGameObjectSyncValues, #hit_points))me.getGameSystem().sendGameSystemEvent(#update_game_visuals)end ifme.startInvincibleAnimation()#set_target:if not me.getStateAllowsMoving() thenreturn TRUEend ifif me.getProp(#pGameObjectSyncValues, #activity_state) = 1 thenme.setProp(#pGameObjectSyncValues, #activity_state, 0)me.setProp(#pGameObjectSyncValues, #activity_timer, 0)me.resetFigureAnimation()if pIsOwnPlayer thenme.getGameSystem().sendGameSystemEvent(#statusbar_createball_stopped, me.getProp(#pGameObjectSyncValues, #snowball_count))end ifend ifme.pGameObjectFinalTarget.setLoc(tdata.x, tdata.y, 0)me.setGameObjectSyncProperty([#move_target_x: tdata.x, #move_target_y: tdata.y])if pIsOwnPlayer thenme.stopWalkLoop()pWalkLoop = playSound("LS-walk-loop-1", void(), [#infiniteloop: 1])end if#set_target_tile:nothing()#start_throw_snowball:if not me.getStateAllowsMoving() then return TRUEif me.getProp(#pGameObjectSyncValues, #snowball_count) <= 0 then return TRUEme.stopMovement()me.startThrowAnimation(tdata)#start_create_snowball:if not me.getStateAllowsMoving() then return TRUEif me.getProp(#pGameObjectSyncValues, #activity_state) = 1 then return TRUEif me.getProp(#pGameObjectSyncValues, #snowball_count) >= getIntVariable("snowwar.snowball.maximum") then return TRUEme.setProp(#pGameObjectSyncValues, #activity_state, 1)me.setProp(#pGameObjectSyncValues, #activity_timer, getIntVariable("ACTIVITY_TIMER_CREATING", 20))me.stopMovement()me.startCreateSnowballAnimation()if pIsOwnPlayer thenme.getGameSystem().sendGameSystemEvent(#statusbar_createball_started)end if#start_snowball_hit:me.startHitAnimation(tdata)#start_stunned:if pIsOwnPlayer thenme.getGameSystem().sendGameSystemEvent(#statusbar_health_update, 0)me.getGameSystem().sendGameSystemEvent(#statusbar_disable_buttons)end ifme.setProp(#pGameObjectSyncValues, #activity_state, 2)me.setProp(#pGameObjectSyncValues, #activity_timer, getIntVariable("ACTIVITY_TIMER_STUNNED", 125))me.stopMovement()me.startStunnedAnimation(tdata)#zero_ball_count:me.setProp(#pGameObjectSyncValues, #snowball_count, 0)if pIsOwnPlayer thenme.getGameSystem().sendGameSystemEvent(#statusbar_ballcount_update, me.getProp(#pGameObjectSyncValues, #snowball_count))end if#award_hit_score:me.incrementScoreBy(getIntVariable("snowwar.score.hitaward"))#award_kill_score:me.incrementScoreBy(getIntVariable("snowwar.score.killaward"))#reset_player:me.setProp(#pGameObjectSyncValues, #player_id, -1)return TRUE#reset_figure,#gameend:me.stopWalkLoop()return me.resetFigureAnimation()otherwise:put "* TileWorldMover: UNDEFINED EVENT:" && tEvent && tdataend caseendon calculateFrameMovement meif not objectp(pRoomObject) then -- jump 18return(error(me, "Room object wrapper missing", #calculateFrameMovement))end if -- jump 18 landingtActivityTimer = me.getProp(#pGameObjectSyncValues, #activity_timer)if tActivityTimer > 0 then -- jump 45if tActivityTimer = 1 then -- jump 10me.activityTimerTriggered()end if -- jump 10 landingme.setProp(#pGameObjectSyncValues, #activity_timer, (me.getProp(#pGameObjectSyncValues, #activity_timer) - 1))end if -- jump 45 landingif me.existsFinalTarget() then -- jump 311tOrigTileLocation = me.pGameObjectLocation.getTileLoc()if me.pGameObjectNextTarget.getLocation() <> me.pGameObjectLocation.getLocation() then -- jump 15tOrigNextTargetLoc = me.pGameObjectNextTarget.getLocation()end if -- jump 15 landingif me.getStateAllowsMoving() then -- jump 12tMoving = me.calculateMovement()end if -- jump 12 landingtDirBody = me.getProp(#pGameObjectSyncValues, #body_direction)if tMoving then -- jump 86if tOrigNextTargetLoc <> me.pGameObjectNextTarget.getLocation() then -- jump 67pRoomObject.gameObjectRefreshLocation(tOrigTileLocation.x, tOrigTileLocation.y, 0.0, tDirBody, tDirBody)pRoomObject.gameObjectNewMoveTarget(me.pGameObjectNextTarget.getTileX(), me.pGameObjectNextTarget.getTileY(), 0.0, tDirBody, tDirBody, "wlk")end if -- jump 67 landing -- jump 140end if -- jump 86 landingme.stopWalkLoop()me.pGameObjectNextTarget.setLoc(me.pGameObjectLocation.x, me.pGameObjectLocation.y, me.pGameObjectLocation.z)me.setGameObjectSyncProperty([#x: me.pGameObjectLocation.x, #y: me.pGameObjectLocation.y, #next_tile_x: me.pGameObjectLocation.getTileX(), #next_tile_y: me.pGameObjectLocation.getTileY()])pRoomObject.gameObjectMoveDone(me.pGameObjectLocation.getTileX(), me.pGameObjectLocation.getTileY(), 0.0, tDirBody, tDirBody, "std")end if -- jump 140 landing -- jump 10end if -- jump 311 landingme.stopWalkLoop()end if -- jump 10 landingtActivityState = me.getProp(#pGameObjectSyncValues, #activity_state)if tActivityState = getIntVariable("ACTIVITY_STATE_STUNNED") or tActivityState = getIntVariable("ACTIVITY_STATE_INVINCIBLE_AFTER_STUN") then -- jump 9return TRUEend if -- jump 9 landingme.checkForSnowballCollisions()endon reserveSpaceForObject me, tLocX, tLocYtWorld = me.getGameSystem().getWorld()if tWorld = 0 then -- jump 8return FALSEend if -- jump 8 landingtWorld.clearObjectFromTileSpace(me.getObjectId())tWorld.reserveTileForObject(me.pGameObjectNextTarget.getTileX(), me.pGameObjectNextTarget.getTileY(), me.getObjectId(), 0)return TRUEendon activityTimerTriggered metActivityState = me.getProp(#pGameObjectSyncValues, #activity_state)if tActivityState = getIntVariable("ACTIVITY_STATE_STUNNED") then -- jump 55me.executeGameObjectEvent(#player_resurrected)me.setProp(#pGameObjectSyncValues, #activity_timer, getIntVariable("ACTIVITY_TIMER_INVINCIBLE_AFTER_STUN"))me.setProp(#pGameObjectSyncValues, #activity_state, getIntVariable("ACTIVITY_STATE_INVINCIBLE_AFTER_STUN"))return TRUEend if -- jump 55 landingif tActivityState = getIntVariable("ACTIVITY_STATE_INVINCIBLE_AFTER_STUN") then -- jump 10me.resetFigureAnimation()end if -- jump 10 landingif tActivityState = getIntVariable("ACTIVITY_STATE_CREATING") then -- jump 19me.executeGameObjectEvent(#increase_ball_count)me.resetFigureAnimation()end if -- jump 19 landingme.setProp(#pGameObjectSyncValues, #activity_state, getIntVariable("ACTIVITY_STATE_NORMAL"))endon calculateMovement metMoveTarget = me.pGameObjectFinalTargettNextTarget = me.pGameObjectNextTargetif not objectp(tMoveTarget) then -- jump 8return FALSEend if -- jump 8 landingtMoveTargetX = tMoveTarget.xtMoveTargetY = tMoveTarget.yif not objectp(me.pGameObjectLocation) then -- jump 8return FALSEend if -- jump 8 landingtCurrentX = me.pGameObjectLocation.xtCurrentY = me.pGameObjectLocation.yif not objectp(tNextTarget) then -- jump 8return FALSEend if -- jump 8 landingtNextTargetX = tNextTarget.xtNextTargetY = tNextTarget.yif tCurrentX = tMoveTargetX and tCurrentY = tMoveTargetY then -- jump 8return FALSEend if -- jump 8 landingif tNextTargetX <> tCurrentX or tNextTargetY <> tCurrentY then -- jump 234tOldX = tCurrentXtOldY = tCurrentYtTargetX = tNextTarget.xtDeltaX = (tTargetX - tCurrentX)if tDeltaX < 0 then -- jump 31if tDeltaX > -SUBTURN_MOVEMENT then -- jump 10tCurrentX = tTargetX -- jump 11end if -- jump 10 landingtCurrentX = (tCurrentX - SUBTURN_MOVEMENT)end if -- jump 11 landing -- jump 34end if -- jump 31 landingif tDeltaX > 0 then -- jump 27if tDeltaX < SUBTURN_MOVEMENT then -- jump 10tCurrentX = tTargetX -- jump 11end if -- jump 10 landingtCurrentX = (tCurrentX + SUBTURN_MOVEMENT)end if -- jump 11 landingend if -- jump 27 landingend if -- jump 34 landingtTargetY = tNextTarget.ytDeltaY = (tTargetY - tCurrentY)if tDeltaY < 0 then -- jump 31if tDeltaY > -SUBTURN_MOVEMENT then -- jump 10tCurrentY = tTargetY -- jump 11end if -- jump 10 landingtCurrentY = (tCurrentY - SUBTURN_MOVEMENT)end if -- jump 11 landing -- jump 34end if -- jump 31 landingif tDeltaY > 0 then -- jump 27if tDeltaY < SUBTURN_MOVEMENT then -- jump 10tCurrentY = tTargetY -- jump 11end if -- jump 10 landingtCurrentY = (tCurrentY + SUBTURN_MOVEMENT)end if -- jump 11 landingend if -- jump 27 landingend if -- jump 34 landingme.pGameObjectLocation.setLoc(tCurrentX, tCurrentY, 0)me.setGameObjectSyncProperty([#x: tCurrentX, #y: tCurrentY])if tCurrentX = tMoveTargetX and tCurrentY = tMoveTargetY then -- jump 8return FALSEend if -- jump 8 landingreturn TRUE -- jump 325end if -- jump 234 landingtGameSystem = me.getGameSystem()tGeometry = tGameSystem.getGeometry()tWorld = tGameSystem.getWorld()tTileX = me.pGameObjectLocation.getTileX()tTileY = me.pGameObjectLocation.getTileY()tMoveDirection360 = tGeometry.getAngleFromComponents((tMoveTargetX - tCurrentX), (tMoveTargetY - tCurrentY))tNextDir = tGeometry.direction360to8(tMoveDirection360)tNextTile = tWorld.getTileNeighborInDirection(tTileX, tTileY, tNextDir)tNextAvailable = tNextTile <> 0if tNextAvailable then -- jump 12tNextAvailable = tNextTile.isAvailable()end if -- jump 12 landingif not tNextAvailable then -- jump 122tNextDir = tGeometry.direction360to8(tGeometry.rotateDirection45DegreesCCW(tMoveDirection360))tNextTile = tWorld.getTileNeighborInDirection(tTileX, tTileY, tNextDir)tNextAvailable = tNextTile <> 0if tNextAvailable then -- jump 12tNextAvailable = tNextTile.isAvailable()end if -- jump 12 landingif not tNextAvailable then -- jump 64tNextDir = tGeometry.direction360to8(tGeometry.rotateDirection45DegreesCW(tMoveDirection360))tNextTile = tWorld.getTileNeighborInDirection(tTileX, tTileY, tNextDir)tNextAvailable = tNextTile <> 0if tNextAvailable then -- jump 12tNextAvailable = tNextTile.isAvailable()end if -- jump 12 landingif not tNextAvailable then -- jump 6tNextTile = 0end if -- jump 6 landingend if -- jump 64 landingend if -- jump 122 landingif tNextTile <> 0 then -- jump 80me.setGameObjectSyncProperty([#body_direction: tNextDir, #next_tile_x: tNextTile.getX(), #next_tile_y: tNextTile.getY()])me.pGameObjectNextTarget.setTileLoc(tNextTile.getX(), tNextTile.getY(), 0)me.reserveSpaceForObject()return(me.calculateMovement())end if -- jump 80 landingend if -- jump 325 landingreturn FALSEendon checkForSnowballCollisions metGameSystem = me.getGameSystem()if tGameSystem = 0 then -- jump 8return FALSEend if -- jump 8 landingtCollision = tGameSystem.pThread.getComponent().getCollision()tBallObjectIdList = tGameSystem.getGameObjectIdsOfType("snowball")if tBallObjectIdList.count < 1 then -- jump 8return FALSEend if -- jump 8 landingtOwnId = me.getObjectId()tlocation = me.getLocation() --PEEKFROMSTACK 2  --PEEKFROMSTACK 0  --PEEKFROMSTACK 0 if count(tBallObjectIdList) <= 1 then -- jump 188 -- backjump 191 landing --PEEKFROMSTACK 2 --PEEKFROMSTACK 1[--nil--, --nil--]getAt(-nil-)tBallObjectId = --nil--tBallObject = tGameSystem.getGameObject(tBallObjectId)tThrowerId = string(tBallObject.getGameObjectProperty(#int_thrower_id))if tThrowerId <> tOwnId and tBallObject.getActive() then -- jump 132if tBallObject.getLocation().z < PLAYER_HEIGHT then -- jump 115if tCollision.testForObjectToObjectCollision(me, tBallObject) then -- jump 101tBallLocX = tBallObject.getLocation().xtBallLocY = tBallObject.getLocation().ytBallLocZ = tBallObject.getLocation().ztBallDirection = tGameSystem.get360AngleFromComponents((tBallLocX - tlocation.x), (tBallLocY - tlocation.y))tBallObject.Remove()me.executeGameObjectEvent(#start_snowball_hit, [#x: tBallLocX, #y: tBallLocY, #z: tBallLocZ, #direction: tBallDirection])end if -- jump 101 landingend if -- jump 115 landingend if -- jump 132 landing(--nil-- + 1) -- backjump 191end if -- jump 188 landing --TRIMFROMSTACK 3return TRUEendon stopMovement meme.stopWalkLoop()me.setLocation(me.pGameObjectNextTarget.x, me.pGameObjectNextTarget.y, me.pGameObjectNextTarget.x)me.setGameObjectSyncProperty([#x: me.pGameObjectNextTarget.x, #y: me.pGameObjectNextTarget.y, #move_target_x: me.pGameObjectNextTarget.x, #move_target_y: me.pGameObjectNextTarget.y])me.resetTargets()if not objectp(pRoomObject) then -- jump 18return(error(me, "Room object wrapper missing", #stopMovement))end if -- jump 18 landingtDirBody = me.getProp(#pGameObjectSyncValues, #body_direction)pRoomObject.gameObjectMoveDone(me.pGameObjectLocation.getTileX(), me.pGameObjectLocation.getTileY(), 0.0, tDirBody, tDirBody, "std")return TRUEendon startHitAnimation me, tdatatDirection = tdata[#direction]tX = tdata[#x]tY = tdata[#y]tZ = tdata[#z]if not objectp(pRoomObject) then -- jump 18return(error(me, "Room object wrapper missing", #startHitAnimation))end if -- jump 18 landingtHumanObject = pRoomObject.getRoomObject()if tHumanObject = 0 then -- jump 18return(error(me, "Room object missing", #startHitAnimation))end if -- jump 18 landingif tDirection >= 225 or tDirection <= 45 then -- jump 17tlocz = (tHumanObject.pSprite.locZ + 1) -- jump 14end if -- jump 17 landingtlocz = (tHumanObject.pSprite.locZ + 1)end if -- jump 14 landingtScreenLoc = me.getGameSystem().getWorld().convertWorldToScreenCoordinate(tX, tY, tZ)tEffect = createObject(#temp, "Snowwar Hit Animation Class")tEffect.define(tScreenLoc, tlocz)pActiveEffects.append(tEffect)return TRUEendon startThrowAnimation me, tdatatGameSystem = me.getGameSystem()if tdata.findPos(#int_target_id) > 0 then -- jump 24tdata[#target_id] = string(tdata[#int_target_id])end if -- jump 24 landingif tdata.findPos(#target_id) > 0 then -- jump 69tTargetObject = tGameSystem.getGameObject(tdata[#target_id])if tTargetObject = 0 then -- jump 18return(error(me, "Target object not found!", #startThrowAnimation))end if -- jump 18 landingtTargetX = tTargetObject.getLocation().xtTargetY = tTargetObject.getLocation().y -- jump 25end if -- jump 69 landingtTargetX = tdata[#TargetX]tTargetY = tdata[#TargetY]end if -- jump 25 landingtlocation = me.getLocation()tDirection = tGameSystem.get8AngleFromComponents((tTargetX - tlocation.x), (tTargetY - tlocation.y))me.setGameObjectSyncProperty([#body_direction: tDirection])if not objectp(pRoomObject) then -- jump 18return(error(me, "Room object wrapper missing", #startThrowAnimation))end if -- jump 18 landingpRoomObject.gameObjectAction("start_throw", tDirection)return TRUEendon startCreateSnowballAnimation meif not objectp(pRoomObject) then -- jump 18return(error(me, "Room object wrapper missing", #startCreateSnowballAnimation))end if -- jump 18 landingpRoomObject.gameObjectAction("start_create")return TRUEendon startStunnedAnimation me, tdataif not objectp(pRoomObject) then -- jump 18return(error(me, "Room object wrapper missing", #startStunnedAnimation))end if -- jump 18 landingpRoomObject.gameObjectAction("start_stunned", tdata)return TRUEendon startInvincibleAnimation meif not objectp(pRoomObject) then -- jump 18return(error(me, "Room object wrapper missing", #startStunnedAnimation))end if -- jump 18 landingpRoomObject.gameObjectAction("start_invincible")return TRUEendon resetFigureAnimation meif not objectp(pRoomObject) then -- jump 18return(error(me, "Room object wrapper missing", #resetFigureAnimation))end if -- jump 18 landingif pDump then -- jump 9put("* resetFigureAnimation calling reset_figure")end if -- jump 9 landingpRoomObject.gameObjectAction("reset_figure")return TRUEendon createRoomObject me, tDataStructpRoomObject = createObject(#temp, getClassVariable("snowwar.object_avatar.roomobject.wrapper.class"))if pRoomObject = 0 then -- jump 18return(error(me, "Cannot create roomobject wrapper!", #createRoomObject))end if -- jump 18 landingreturn(pRoomObject.define(tDataStruct))endon removeRoomObject meif not objectp(pRoomObject) then -- jump 9return TRUEend if -- jump 9 landingpRoomObject.deconstruct()pRoomObject = void()return TRUEendon getRoomObjectImage meif not objectp(pRoomObject) then -- jump 8return FALSEend if -- jump 8 landingreturn(pRoomObject.getPicture())endon getStateAllowsMoving metstate = me.getProp(#pGameObjectSyncValues, #activity_state)tPossibleStates = [getIntVariable("ACTIVITY_STATE_NORMAL"), getIntVariable("ACTIVITY_STATE_CREATING"), getIntVariable("ACTIVITY_STATE_INVINCIBLE_AFTER_STUN")]return(tPossibleStates.findPos(tstate) > 0)endon stopWalkLoop meif pWalkLoop <> void() thenstopSoundChannel(pWalkLoop)end ifpWalkLoop = void()return TRUEendon incrementScoreBy me, tPointsif tPoints = 0 then -- jump 9return TRUEend if -- jump 9 landingme.setProp(#pGameObjectSyncValues, #score, (me.getProp(#pGameObjectSyncValues, #score) + tPoints))me.getGameSystem().sendGameSystemEvent(#team_score_updated, [[#team_id: me.getProp(#pGameObjectSyncValues, #team_id), #score_add: tPoints]])if pIsOwnPlayer then -- jump 29me.getGameSystem().sendGameSystemEvent(#personal_score_updated, me.getProp(#pGameObjectSyncValues, #score))end if -- jump 29 landingreturn TRUEend